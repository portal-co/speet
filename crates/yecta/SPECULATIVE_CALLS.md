# Yecta Control Flow Integration: Speculative Call Detection

## Current State
`yecta` provides a reactive system for generating WASM control flow. It uses exceptions (`EscapeTag`) to handle non-local control flow (e.g., longjmp, cross-function jumps) and `ReturnCall` for tail-call optimization of cycles.

## Fast Speculative Call Detection (Integration Goal)
The goal is to implement a fast path for indirect calls where the target is "speculatively" known (e.g., from a branch target buffer or previous execution).

### 1. Speculative Call Pattern
When recompiling indirect calls (e.g., `call [rax]` in x86_64 or `jalr` in RISC-V), the reactor should emit a check against a "fast-path" function index.

```wasm
;; Pseudo-WASM generated by Reactor
local.get $target_addr
global.get $last_known_target
i64.eq
if
  call $recompiled_target_fast_path
else
  call $slow_path_resolver
end
```

### 2. Integration with yecta
- **Snippet-based Detection**: Implement a `SpeculativeCallSnippet` that emits the check and the fast-path call.
- **Reactor Support**: Add a `speculative_ji` method to the `Reactor` that takes a "predicted" `FuncIdx`.

### 3. Architecture Integration
- **x86_64**: Use for `call` and `jmp` instructions with register operands.
- **RISC-V**: Use for `jalr` where the target is frequently the same (e.g., return from function).

## Exception-Based Function Calls
The current `yecta` documentation mentions exceptions for returns. It's important to clarify that this system allows:
1. **Direct Recompilation**: Cross-function jumps are recompiled into WASM `return_call`.
2. **Exception Escapes**: When a jump target is outside the current megabinary's pre-compiled "neighborhood", an exception is thrown to the vkernel to resolve and potentially recompile the next block.
